{"version":3,"file":"f123DataMapping-DL4nWXCf.js","sources":["../../src/utils/f123DataMapping.ts"],"sourcesContent":["import { findTeamByName } from '../data/f123Teams';\n\n// Utility functions for mapping F1 23 UDP data to display format\n\n// Driver Status Mapping\nexport const getDriverStatus = (status: number): string => {\n  switch (status) {\n    case 0: return 'IN_GARAGE';\n    case 1: return 'RUNNING';  // FLYING_LAP -> RUNNING\n    case 2: return 'IN_LAP';\n    case 3: return 'OUT_LAP';\n    case 4: return 'RUNNING';  // ON_TRACK -> RUNNING\n    default: return 'RUNNING';\n  }\n};\n\n// Result Status Mapping (for retirements)\nexport const getResultStatus = (resultStatus: number): string => {\n  switch (resultStatus) {\n    case 0: return 'INVALID';\n    case 1: return 'INACTIVE';\n    case 2: return 'RUNNING';  // ACTIVE\n    case 3: return 'FINISHED';\n    case 4: return 'DNF';      // DID NOT FINISH\n    case 5: return 'DSQ';     // DISQUALIFIED\n    case 6: return 'NCL';     // NOT CLASSIFIED\n    case 7: return 'RET';     // RETIRED\n    default: return 'RUNNING';\n  }\n};\n\n// Tire Compound Mapping - Simplified to S, M, H, I, W\nexport const getTireCompound = (compound: number): 'S' | 'M' | 'H' | 'I' | 'W' => {\n  switch (compound) {\n    case 16: return 'S'; // C5 (softest)\n    case 17: return 'S'; // C4\n    case 18: return 'M'; // C3\n    case 19: return 'H'; // C2\n    case 20: return 'H'; // C1\n    case 21: return 'H'; // C0 (treat as hard)\n    case 7: return 'I';  // Intermediate\n    case 8: return 'W';  // Wet\n    default: return 'M';\n  }\n};\n\n// Visual Tire Compound Mapping - Uses different values (16=soft, 17=medium, 18=hard)\nexport const getVisualTireCompound = (compound: number): 'S' | 'M' | 'H' | 'I' | 'W' => {\n  switch (compound) {\n    case 16: return 'S'; // Soft\n    case 17: return 'M'; // Medium\n    case 18: return 'H'; // Hard\n    case 7: return 'I';  // Intermediate\n    case 8: return 'W';  // Wet\n    default: return 'M'; // Default to Medium if unknown\n  }\n};\n\n// Gap Formatting - Add + prefix\n// Format: +SSS.mmm (if < 60s) or +M:ss.mmm (if < 10min) or +MM:ss.mmm (if >= 10min)\nexport const formatGap = (gapMs: number): string => {\n  if (gapMs === 0) return '0.000'; // Show 0.000 instead of LEADER for consistency\n  const seconds = gapMs / 1000;\n  if (seconds < 60) {\n    return `+${seconds.toFixed(3)}`; // +SSS.mmm\n  } else {\n    const minutes = Math.floor(seconds / 60);\n    const remainingSeconds = seconds % 60;\n    const minutesStr = minutes >= 10 ? minutes.toString().padStart(2, '0') : minutes.toString(); // M or MM\n    const secondsParts = remainingSeconds.toFixed(3).split('.');\n    const secondsFormatted = `${secondsParts[0].padStart(2, '0')}.${secondsParts[1]}`; // ss.mmm (always two digits)\n    return `+${minutesStr}:${secondsFormatted}`; // +M:ss.mmm or +MM:ss.mmm\n  }\n};\n\n// Lap Time Formatting - Fixed width (9 chars: MM:SS.mmm)\nexport const formatLapTime = (timeInMs: number): string => {\n  if (timeInMs === 0) return '--:--.---'; // 9 chars: --:--.---\n  const totalSeconds = timeInMs / 1000;\n  const minutes = Math.floor(totalSeconds / 60);\n  const seconds = (totalSeconds % 60);\n  \n  // Always format as MM:SS.mmm for fixed width (9 chars)\n  const minutesStr = minutes.toString().padStart(2, '0');\n  const secondsStr = seconds.toFixed(3);\n  const secondsParts = secondsStr.split('.');\n  const secondsFormatted = `${secondsParts[0].padStart(2, '0')}.${secondsParts[1]}`;\n  return `${minutesStr}:${secondsFormatted}`;\n};\n\n// Sector Time Formatting - Fixed width (6 chars: SS.mmm, or M:SS.mmm if minutes)\nexport const formatSectorTime = (timeInMs: number, minutes: number = 0): string => {\n  if (timeInMs === 0) return '--.---'; // 6 chars: --.---\n  const totalSeconds = timeInMs / 1000;\n  const totalMinutes = minutes + Math.floor(totalSeconds / 60);\n  const remainingSeconds = (totalSeconds % 60);\n  \n  if (totalMinutes > 0) {\n    // Format as M:SS.mmm for fixed width\n    const minutesStr = totalMinutes.toString().padStart(1, '0');\n    const secondsStr = remainingSeconds.toFixed(3).padStart(6, '0');\n    return `${minutesStr}:${secondsStr}`;\n  } else {\n    // Format as SS.mmm for fixed width (6 chars)\n    return remainingSeconds.toFixed(3).padStart(6, '0');\n  }\n};\n\n// Position Change Calculation\nexport const calculatePositionChange = (gridPosition: number, currentPosition: number): number => {\n  return gridPosition - currentPosition; // +2 = gained 2 positions, -1 = lost 1 position\n};\n\n// Team Color Mapping\nexport const getTeamColor = (teamName: string): string => {\n  const team = findTeamByName(teamName);\n  return team?.color ?? '#FFFFFF';\n};\n\n// Driver Abbreviation\nexport const getDriverAbbreviation = (driverName: string): string => {\n  if (!driverName) return 'UNK';\n  const parts = driverName.split(' ');\n  if (parts.length >= 2) {\n    return (parts[0][0] + parts[1][0] + parts[1][1]).toUpperCase();\n  }\n  return driverName.substring(0, 3).toUpperCase();\n};\n\n// Helper to map status text for STATUS column (include all statuses; keep PITTING/PIT)\nconst getDriverStatusDisplay = (udpData: any): string => {\n  const lapData = udpData?.lapData || {};\n  const resultStatus = lapData.resultStatus ?? 2; // 0 INVALID, 1 INACTIVE, 2 ACTIVE, 3 FINISHED, 4 DNF, 5 DSQ, 6 NCL, 7 RET\n  const pitStatus = lapData.pitStatus ?? 0;       // 0 none, 1 pitting, 2 in pit area\n  const driverStatus = lapData.driverStatus ?? 0; // 0 in garage, 1 flying, 2 in lap, 3 out lap, 4 on track\n\n  // FINISHED takes priority over everything (including pit status)\n  if (resultStatus === 3) return 'FINISHED';\n\n  // Show all other result statuses when present\n  switch (resultStatus) {\n    case 5: return 'DSQ';\n    case 7: return 'RET';\n    case 4: return 'DNF';\n    case 6: return 'NCL';\n    case 1: return 'INACTIVE';\n    case 0: return 'INVALID';\n    // 2 ACTIVE: fall through to live/pit statuses below\n  }\n\n  // Pit statuses (map both to PIT)\n  if (pitStatus === 1) return 'PIT';\n  if (pitStatus === 2) return 'PIT';\n\n  // Driver live statuses\n  if (driverStatus === 0) return 'PIT';      // in garage\n  if (driverStatus === 3) return 'OUT LAP';\n  if (driverStatus === 2) return 'IN LAP';\n  if (driverStatus === 1 || driverStatus === 4) return 'RUNNING';\n\n  return 'RUNNING';\n};\n\n// Convert F1 23 UDP data to LiveTimings format\nexport const convertToLiveTimingsFormat = (udpData: any, leaderBestLapTime?: number, leaderLapNum?: number, isRace?: boolean, frontCarLapNum?: number): any => {\n  const lapData = udpData.lapData;\n  const carStatus = udpData.carStatus;\n  const stintHistory = udpData.stintHistory || [];\n  \n  return {\n    id: udpData.carIndex?.toString() ?? udpData.carNumber?.toString() ?? '0', // Use carIndex (always unique) instead of carNumber for React keys\n    position: lapData.carPosition || 0,\n    // isFastestLap removed - now using event-based fastestLapCarIndex from FTLP event packet\n    driverName: udpData.driverName || 'Unknown Driver',\n    driverAbbreviation: getDriverAbbreviation(udpData.driverName),\n    teamColor: getTeamColor(udpData.teamName),\n    \n    // Timing data\n    fastestLap: formatLapTime(lapData.bestLapTimeInMS || lapData.lastLapTimeInMS || 0),\n    fastestLapTire: (lapData.bestLapTimeInMS || lapData.lastLapTimeInMS) > 0 \n      ? getTireCompound(carStatus.actualTyreCompound || 0) \n      : undefined, // Only set if there's a valid lap time\n    status: getDriverStatusDisplay(udpData),\n    lastLapTime: formatLapTime(lapData.lastLapTimeInMS || 0),\n    bestLap: formatLapTime(lapData.bestLapTimeInMS || lapData.lastLapTimeInMS || 0),\n    bestLapTire: getTireCompound(carStatus.actualTyreCompound || 0), // Use current tire as approximation\n    \n    // Gap and interval - show terminal status when applicable, else gap to leader\n    gap: (() => {\n      const result = lapData.resultStatus || 0;\n      if (result === 5) return 'DSQ';\n      if (result === 7) return 'RET';\n      if (result === 4) return 'DNF';\n      if (lapData.carPosition === 1) return '--'; // Leader - use placeholder\n      \n      // For race sessions, use deltaToRaceLeaderInMS directly (UDP provides correct values)\n      if (isRace && lapData.deltaToRaceLeaderInMS !== undefined) {\n        // If delta is 0 and lap numbers differ, calculate laps down\n        if (lapData.deltaToRaceLeaderInMS === 0 && leaderLapNum && lapData.currentLapNum && lapData.currentLapNum !== leaderLapNum) {\n          const lapsDown = leaderLapNum - lapData.currentLapNum;\n          return `+${lapsDown} Lap${lapsDown > 1 ? 's' : ''}`;\n        }\n        \n        // Normal time delta (non-zero)\n        if (lapData.deltaToRaceLeaderInMS > 0) {\n          return formatGap(lapData.deltaToRaceLeaderInMS);\n        }\n        \n        // Leader case (delta 0, same lap number)\n        return '--';\n      }\n      \n      // For practice/qualifying, use best lap time comparison\n      const driverBestLap = lapData.bestLapTimeInMS || lapData.lastLapTimeInMS || 0;\n      if (!leaderBestLapTime || leaderBestLapTime === 0 || driverBestLap === 0) {\n        return '--';\n      }\n      \n      const gapToLeaderBest = driverBestLap - leaderBestLapTime;\n      return formatGap(gapToLeaderBest);\n    })(),\n    interval: (() => {\n      // For leader, show placeholder\n      if (lapData.carPosition === 1) {\n        return '--';\n      }\n      \n      // For race sessions, handle delta === 0 case (lapped by car in front)\n      if (isRace && lapData.deltaToCarInFrontInMS !== undefined) {\n        // If delta is 0 and lap numbers differ, calculate laps down\n        if (lapData.deltaToCarInFrontInMS === 0 && frontCarLapNum && lapData.currentLapNum && lapData.currentLapNum !== frontCarLapNum) {\n          const lapsDown = frontCarLapNum - lapData.currentLapNum;\n          return `+${lapsDown} Lap${lapsDown > 1 ? 's' : ''}`;\n        }\n        \n        // Normal time delta (non-zero)\n        if (lapData.deltaToCarInFrontInMS > 0) {\n          return formatGap(lapData.deltaToCarInFrontInMS);\n        }\n        \n        // Same lap, very close (delta 0, same lap number)\n        return '--';\n      }\n      \n      // For practice/qualifying or non-race, use delta directly\n      if (lapData.deltaToCarInFrontInMS !== undefined && lapData.deltaToCarInFrontInMS > 0) {\n        return formatGap(lapData.deltaToCarInFrontInMS);\n      }\n      return '--';\n    })(),\n    \n    // Position changes\n    positionChange: calculatePositionChange(lapData.gridPosition || 0, lapData.carPosition || 0),\n    \n    // Sector times - use best lap sector times for practice/qualifying tables\n    sector1Time: formatSectorTime((udpData.bestLapSector1Time || 0) * 1000, 0), // Convert back to ms for formatting\n    sector2Time: formatSectorTime((udpData.bestLapSector2Time || 0) * 1000, 0), // Convert back to ms for formatting\n    sector3Time: formatSectorTime((udpData.bestLapSector3Time || 0) * 1000, 0), // Convert back to ms for formatting\n    \n    // Status fields\n    driverStatus: getDriverStatus(lapData.driverStatus || 0),\n    \n    // Tire data\n    tireCompound: getTireCompound(carStatus.actualTyreCompound || 0),\n    lapsOnCompound: carStatus.tyresAgeLaps || 0,\n    \n    // Stint tracking data - simplified to use UDP directly\n    // Use only visual compound for stint graph (matches what user sees in-game)\n    currentTire: getVisualTireCompound(carStatus.visualTyreCompound || 0),\n    stintLaps: carStatus.tyresAgeLaps || 0, // Direct from UDP\n    totalRaceLaps: udpData.sessionData?.totalLaps || 52, // Use dynamic session data\n    lapNumber: lapData.currentLapNum || 0,\n    \n    \n    // Micro-sectors - use backend-provided array (progressive coloring as segments complete)\n    microSectors: udpData.microSectors || [],\n    \n    // Last completed sector times (right-side columns) - updated on sector completion by backend\n    LS1: (() => {\n      // Backend sends LS1 in milliseconds, with separate minutes field\n      const s1Ms = udpData.LS1 || 0;\n      const s1Min = udpData.LS1Minutes || 0;\n      return s1Ms > 0 ? formatSectorTime(s1Ms, s1Min) : '--.---';\n    })(),\n    LS2: (() => {\n      // Backend sends LS2 in milliseconds, with separate minutes field\n      const s2Ms = udpData.LS2 || 0;\n      const s2Min = udpData.LS2Minutes || 0;\n      return s2Ms > 0 ? formatSectorTime(s2Ms, s2Min) : '--.---';\n    })(),\n    LS3: (() => {\n      // Backend sends LS3 in seconds (already calculated)\n      const s3Seconds = udpData.LS3 || 0;\n      return s3Seconds > 0 ? formatSectorTime(s3Seconds * 1000, 0) : '--.---';\n    })(),\n    \n    // Stint history - use visual compound for stint graph (matches what user sees in-game)\n    stintHistory: stintHistory.map((stint: any) => ({\n      compound: getVisualTireCompound(stint.tyreVisualCompound || stint.tyreActualCompound || 18),\n      laps: stint.endLap || 0\n    })),\n  };\n};\n\n// Generate micro-sectors from sector times\nexport const generateMicroSectorsFromSectors = (\n  sector1Ms: number,\n  sector2Ms: number,\n  sector3Ms: number\n): Array<'purple' | 'green' | 'yellow' | 'grey'> => {\n  const microSectors: Array<'purple' | 'green' | 'yellow' | 'grey'> = [];\n  \n  // Split each sector into 8 micro-sectors\n  const sectors = [sector1Ms, sector2Ms, sector3Ms];\n  \n  sectors.forEach(sectorMs => {\n    if (sectorMs > 0) {\n      const sectorTime = sectorMs / 8; // Split into 8 micro-sectors\n      for (let i = 0; i < 8; i++) {\n        microSectors.push(getMicroSectorColor(sectorTime));\n      }\n    } else {\n      // Fill with grey if no data\n      for (let i = 0; i < 8; i++) {\n        microSectors.push('grey');\n      }\n    }\n  });\n  \n  return microSectors;\n};\n\n// Get micro-sector color based on time\nconst getMicroSectorColor = (timeMs: number): 'purple' | 'green' | 'yellow' | 'grey' => {\n  // This is a simplified implementation\n  // In reality, you'd compare against fastest sector times\n  if (timeMs < 15000) return 'purple'; // Very fast\n  if (timeMs < 20000) return 'green';  // Fast\n  if (timeMs < 25000) return 'yellow'; // Average\n  return 'grey'; // Slow\n};\n\n// Session Type Name Helper\nexport const getSessionTypeName = (sessionType: number): string => {\n  const sessionTypes = [\n    'Unknown', 'Practice 1', 'Practice 2', 'Practice 3',\n    'Short Practice', 'Q1', 'Q2', 'Q3', 'Short Qualifying',\n    'One Shot Qualifying', 'Race', 'Race 2', 'Time Trial'\n  ];\n  return sessionTypes[sessionType] || 'Unknown';\n};\n\n// Session Category Helper\nexport const getSessionCategory = (sessionType: number): 'PRACTICE' | 'QUALIFYING' | 'RACE' => {\n  // Practice sessions (1-4)\n  if (sessionType >= 1 && sessionType <= 4) {\n    return 'PRACTICE';\n  }\n  // Qualifying sessions (5-9)\n  if (sessionType >= 5 && sessionType <= 9) {\n    return 'QUALIFYING';\n  }\n  // Race sessions (10-11)\n  if (sessionType >= 10 && sessionType <= 11) {\n    return 'RACE';\n  }\n  // Default to PRACTICE for unknown/other types\n  return 'PRACTICE';\n};"],"names":["getDriverStatus","status","getResultStatus","resultStatus","getTireCompound","compound","getVisualTireCompound","formatGap","gapMs","seconds","minutes","remainingSeconds","minutesStr","secondsParts","secondsFormatted","formatLapTime","timeInMs","totalSeconds","formatSectorTime","totalMinutes","secondsStr","calculatePositionChange","gridPosition","currentPosition","getTeamColor","teamName","team","findTeamByName","getDriverAbbreviation","driverName","parts","getDriverStatusDisplay","udpData","lapData","pitStatus","driverStatus","convertToLiveTimingsFormat","leaderBestLapTime","leaderLapNum","isRace","frontCarLapNum","carStatus","stintHistory","_a","_b","result","lapsDown","driverBestLap","gapToLeaderBest","_c","s1Ms","s1Min","s2Ms","s2Min","s3Seconds","stint","getSessionTypeName","sessionType","getSessionCategory"],"mappings":"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"}